# Golang中的变量

> 原文：<https://golangbyexample.com/variables-in-golang-complete-guide/>

这是 golang 综合教程系列的第 6 章。本系列其他章节参考本链接–[<u>【格朗综合教程系列】</u>](https://golangbyexample.com/golang-comprehensive-tutorial/)

**下一教程**–[所有基本数据类型](https://golangbyexample.com/all-basic-data-types-golang/)
**上一教程**–[包和模块–第 2 部分](https://golangbyexample.com/packages-modules-go-second/)

现在让我们来看看当前的教程。下面是当前教程的目录。

# **什么是变量**

变量是内存位置的名称。该存储位置可以存储任何类型的值。因此，每个变量都有一个相关的类型，它决定了变量的大小和范围，以及在该变量上定义的操作。

# **命名惯例**

*   变量名只能以字母或下划线开头。

*   其后可以跟任意数量的字母、数字或下划线

*   Go 区分大小写，因此大写字母和小写字母被区别对待。

*   变量名称不能是 Go 中的任何关键字名称

*   变量名的长度没有限制。

*   但最好有最佳长度的变量名。

# **声明变量**

在 GO 中，变量是使用 **var** 关键字声明的，但是也有其他声明变量的方法，我们将在本教程的后面部分看到。让我们探索声明变量的不同方法

## **无初始值的单变量申报**

下面是没有分配初始值的单个变量声明的格式。首先是 **var** 关键字，其次是**变量名**，第三是**变量类型**。还要注意，当没有提供值时，变量用该类型的默认值初始化，该默认值也称为该类型的零值。在 Go 中 **int** 的默认值或零值为零

**var <变量 _ 名称> <类型>**

参见下面的例子，它声明了一个名为 **aaa** 的类型为 **int** 的 var

```go
package main

import "fmt"

func main() {
    var aaa int
    fmt.Println(aaa)
}
```

**输出:**将打印 int 的默认值，该值为零

```go
0
```

## **单变量带初始值申报**

下面是赋值初始值的单个变量声明的格式。一切都和上面一样，唯一附加的是我们在最后给变量赋值

**var <变量 _ name>T4【类型】> = <值>**

参见下面的例子，它声明了一个名为 **aaa** 的类型为 **int** 的 var，并给它一个值 **8**

```go
package main

import "fmt"

func main() {
    var aaa int = 8
    fmt.Println(aaa)
}
```

**输出:**

```go
8
```

## **多变量无初始值申报**

下面是没有分配初始值的多变量声明的格式。请注意，只能一起声明相同类型的变量。类型在最后

**var < name1 >，< name2 >** ，…。 **<名称> <类型>**

见下面的例子

```go
package main

import "fmt"

func main() {
    var aaa, bbb int
    fmt.Println(aaa)
    fmt.Println(bbb)
}
```

**输出:**打印 **int** 的缺省值或零值，对于 **aaa** 和 **bbb** 都为零

```go
0
0
```

## **多变量带初始值申报**

下面是赋值初始值的多变量声明的格式。请注意，只能一起声明相同类型的变量。类型在最后

**var < name1 >，< name2 >，…..，<nameN><type>=<value 1>，< value2 >，…..，<值>**

参见下面的代码示例。变量 **aaa** 和 **bbb** 在单个声明中分别被赋予值 8 和 9

```go
package main

import "fmt"

func main() {
    var aaa, bbb int = 8, 9
    fmt.Println(aaa)
    fmt.Println(bbb)
}
```

**输出:**

```go
8
9
```

## **声明不同类型的变量**

下面是用不同类型声明多个变量的格式。此时，值可以或不能分配给变量。未赋值的变量将获得该类型的默认值。在下面的例子中，我们看到三个声明。

```go
package main

import "fmt"

func main() {
    var (
        aaa int
        bbb int    = 8
        ccc string = "a"
    )

    fmt.Println(aaa)
    fmt.Println(bbb)
    fmt.Println(ccc)
}
```

**输出:**

```go
0
8
a
```

## **无类型或类型推断的变量声明**

也可以在不指定类型的情况下声明变量。

GO 编译器会根据分配给变量的值计算出类型。所以如果变量有初始值，那么类型可以省略。这也叫**类型推断**。下面是这种声明的格式

**为<变型 _ 名称>= =<值>**

下面是基本类型 **int** 、 **float** 、**复数**、**字符串**、**布尔**、**字符**的类型推断表。基本意思是，如果值是整数，推断出的变量类型将是 **int** ，如果值是 float，那么根据下表推断出的变量类型将是 **float64** 等等。

<figure class="wp-block-table is-style-stripes">

| 整数 | （同 Internationalorganizations）国际组织 |
| 漂浮物 | float64 |
| 复数 | 复杂 128 |
| 用线串 | 线 |
| 布尔运算 | 弯曲件 |
| 特性 | int32 或符文 |

</figure>

对于其他类型，如**数组**、**指针**、**结构、**等，将根据值进行类型推断。让我们看一个上述观点的工作示例。请注意，t 的类型被正确地推断为 int，因为分配给它的值是 int 的 123。类似地，类型 u 也被正确地推断为**字符串**，因为分配给它的值是一个**字符串**。

还要注意变量 **z** 的类型被正确地推断为结构**主样本**

```go
package main

import "fmt"

func main() {
    var t = 123      //Type Inferred will be int
    var u = "circle" //Type Inferred will be string
    var v = 5.6      //Type Inferred will be float64
    var w = true     //Type Inferred will be bool
    var x = 'a'      //Type Inferred will be rune
    var y = 3 + 5i   //Type Inferred will be complex128
    var z = sample{name: "test"}  //Type Inferred will be main.Sample

    fmt.Printf("Type: %T Value: %v\n", t, t)
    fmt.Printf("Type: %T Value: %v\n", u, u)
    fmt.Printf("Type: %T Value: %v\n", v, v)
    fmt.Printf("Type: %T Value: %v\n", w, w)
    fmt.Printf("Type: %T Value: %v\n", x, x)
    fmt.Printf("Type: %T Value: %v\n", y, y)
    fmt.Printf("Type: %T Value: %v\n", z, z)
}

type sample struct {
    name string
}
```

**输出:**

```go
Type: int Value: 123
Type: string Value: circle
Type: float64 Value: 5.6
Type: bool Value: true
Type: int32 Value: 97
Type: complex128 Value: (3+5i)
Type: main.sample Value: &{test}
```

## **短变量申报**

Go 提供了另一种声明变量的方式，即使用 **:=** 运算符。当使用 **:=** 运算符时， **var** 关键字和类型信息都可以省略。下面是这种声明的格式

```go
 <variable_name>:= <value></value></variable_name>
```

类型推断将如上所述发生。让我们看一个工作示例

```go
package main

import "fmt"

func main() {
    t := 123      //Type Inferred will be int
    u := "circle" //Type Inferred will be string
    v := 5.6      //Type Inferred will be float64
    w := true     //Type Inferred will be bool
    x := 'a'      //Type Inferred will be rune
    y := 3 + 5i   //Type Inferred will be complex128
    z := sample{name: "test"}  //Type Inferred will be main.Sample

    fmt.Printf("Type: %T Value: %v\n", t, t)
    fmt.Printf("Type: %T Value: %v\n", u, u)
    fmt.Printf("Type: %T Value: %v\n", v, v)
    fmt.Printf("Type: %T Value: %v\n", w, w)
    fmt.Printf("Type: %T Value: %v\n", x, x)
    fmt.Printf("Type: %T Value: %v\n", y, y)
    fmt.Printf("Type: %T Value: %v\n", z, z)
}

type sample struct {
    name string
}
```

**输出**

```go
Type: int Value: 123
Type: string Value: circle
Type: float64 Value: 5.6
Type: bool Value: true
Type: int32 Value: 97
Type: complex128 Value: (3+5i)
Type: main.sample Value: &{test}
```

关于:=运算符需要注意的几点

*   :=运算符仅在函数中可用。不允许在函数外使用。
*   使用:=声明的变量不能使用:=运算符重新声明。所以下面的语句会引发编译器错误“**左侧没有新的变量:=“**”。

```go
a := 8
a := 16
```

*   :=运算符也可用于在一行中声明多个变量。见下面的例子

```go
a,b := 1, 2
```

*   在多个声明的情况下，如果左侧的变量中至少有一个是新的，那么，:=也可以再次用于特定的变量。见下面的例子。请注意，再次使用声明 b:=只有当变量中至少有一个是新的，即变量 **c** 时，这才是可能的。在这种情况下，它充当变量 **b** 的赋值

```go
package main

import "fmt"

func main() {
    a, b := 1, 2
    b, c := 3, 4
    fmt.Println(a, b, c)
}
```

**输出:**

```go
1, 3, 4
```

# **【重要点】**

*   未使用的变量将被报告为编译器错误。GO 编译器不允许任何未使用的变量。这是 GO 中的一个优化。这同样适用于常量，我们将在后面看到。例如，下面的程序将引发编译器错误

```go
a declared but not used
```

```go
package main

func main() {
    var a = 1
}
```

*   在内部范围内声明的变量与在外部范围内声明的变量同名，这将隐藏外部范围内的变量。

```go
package main

import "fmt"

var a = 123

func main() {
    var a = 456
    fmt.Println(a)
}
```

**输出:**

```go
456
```

*   变量表达式–虽然声明变量也可以被赋予表达式或函数调用。见下面的例子。
    *   变量 **a** 用表达式 5 +3 声明
    *   变量 **b** 用函数调用数学来声明。Max(4，5)，其结果将在运行时分配给 b。

```go
package main
import (
    "fmt"
    "math"
)
func main() {
    a := 5 + 3
    b := math.Max(4, 5)
    fmt.Println(a)
    fmt.Println(b)
}
```

**输出:**

```go
8
5
```

*   变量一旦用特定类型初始化，以后就不能分配不同类型的值。这对于短手申报是适用的。见下面的例子

```go
package main

func main() {
    var aaa int = 1
    aaa = "atest"

    bbb := 1
    bbb = "btest"
}
```

**输出:**

```go
cannot use "atest" (type untyped string) as type int in assignment
cannot use "btest" (type untyped string) as type int in assignment
```

变量 **aaa** 已经被分配了一个类型 **int** ，因此编译器在给它分配类型字符串值时会产生错误。对于变量 **bbb** ，推断出的类型是 **int，**，因此在为其赋值类型字符串时也会引发编译器错误。

# **变量范围(局部和全局变量)**

变量声明可以在包级、函数级或块级完成。变量的范围定义了该变量可访问的位置以及变量的寿命。Golang 变量可以根据范围分为两类

*   局部变量

*   全局变量

## **局部变量**

*   局部变量是在块或函数级中定义的变量

*   块的一个例子是 for 循环或 range 循环等。

*   这些变量只能从它们的块或函数中访问

*   这些变量只存在到声明它们的块或函数的末尾。之后就是垃圾回收。

见下面的例子

*   在 for 循环之后，I 不可用

*   同样，aaa 在声明它的函数之外是不可用的。

因此，下面的程序将引发编译器错误

```go
undefined: i
undefined: aaa
```

**代码:**

```go
package main

import "fmt"

func main() {
    var aaa = "test"
    fmt.Println(aaa)
    for i := 0; i < 3; i++ {
        fmt.Println(i)
    }
    fmt.Println(i)
}

func testLocal() {
    fmt.Println(aaa)
}
```

## **全局变量**

*   如果变量在任何函数或块范围之外的文件顶部声明，那么它在包中就是全局变量。

*   如果这个变量名以小写字母开头，那么可以从包含这个变量定义的包中访问它。

*   如果变量名以大写字母统计，那么可以从不同的包外部访问它，而不是从声明它的包外部。

*   全局变量在程序的整个生命周期中都是可用的

例如，在下面的程序变量**中，aaa** 将是一个全局变量，在整个**主**包中可用。它将在**主**包内的任何功能中可用。请注意，变量名在**主**包之外不可用，因为它的名称以小写字母开头。

```go
package main

import "fmt"

var aaa = "test"

func main() {
    testGlobal()
}

func testGlobal() {
    fmt.Println(aaa)
}
```

**输出:**

```go
test
```

# **结论**

这都是关于 golang 中的变量。希望你喜欢这篇文章。请在评论中分享反馈或改进或错误。

****下一教程**–[所有基本数据类型](https://golangbyexample.com/all-basic-data-types-golang/)
**上一教程**–[包和模块–第 2 部分](https://golangbyexample.com/packages-modules-go-second/)**